## Kata 04：基于接口的中间件链

**目标惯用法：** 接口设计、中间件模式、组合优于继承  
**难度：** 🔴 高级

---

## 🧠 背后动机（Why）

面向对象背景的开发者在构建流水线（pipeline）时，常常本能地使用类层次和继承。  
在 Go 中，**接口让“组合优于继承”成为首选**。  

不惯用的方式：定义一个 `BaseHandler` 基类，通过虚方法派生。  
惯用 Go 的方式：使用小接口并将它们组合起来。  

这种模式支撑了 `http.Handler`、`io.Reader` 等标准库模式，但很多来自其它生态的开发者不容易在自己的场景中看出：**何时该把接口“拆小”，如何拆？**

---

## 🎯 场景设定（Scenario）

你正在构建一个**实时用户事件分析流水线**。每个事件需要按顺序经过多级处理：验证、富化（enrichment）、过滤、最终存储。将来会频繁新增处理阶段。

流水线必须：
- 模块化（能方便地添加/移除阶段，而无需重写核心逻辑）；
- 可观测（每个阶段能暴露度量指标）；
- 可恢复（非致命错误不会中断整个流水线）。

---

## 🛠 挑战内容（Challenge）

创建一个用于处理用户事件的中间件链。

### 1. 功能需求（Functional Requirements）

- [ ] 通过可配置的中间件链处理事件；
- [ ] 每个中间件都可以修改、过滤或拒绝事件；
- [ ] 为每个阶段提供指标（计数器、延迟等）；
- [ ] 支持通过上下文取消实现优雅停机。

### 2. “惯用”约束（通过/失败标准）

为通过此 Kata，**必须**严格遵守：

- [ ] **小接口：** 定义 `Processor` 接口，仅包含一个方法：  
  `Process(context.Context, Event) ([]Event, error)`
- [ ] **中间件组合：** 每个中间件必须实现 `Processor` 接口，并包装另外一个 `Processor`；
- [ ] **函数式选项：** 使用函数式选项配置中间件（例如 `WithMetricsCollector()`）；
- [ ] **上下文传播：** 所有中间件必须尊重上下文取消；
- [ ] **零全局状态：** 禁止使用包级变量存储配置或状态；
- [ ] **可测试性优先：** 每个中间件都必须能被单独单元测试。

---

## 🧪 自我校验（Self-Correction）

用以下场景验证你的实现：

1. **“无限循环”测试**
   - 创建一个中间件，使其从 1 个输入事件生成 2 个输出事件；
   - 再将其与一个过滤中间件链在一起；
   - **失败条件：** 事件数量失控倍增，或内存使用呈指数增长。

2. **“上下文泄漏”测试**
   - 添加一个内部有 10 秒超时的中间件；
   - 在 1 秒后取消上下文；
   - **失败条件：** 任意中间件在上下文取消后仍继续处理。

3. **“接口污染”测试**
   - 尝试添加一个需要数据库连接的新中间件；
   - **失败条件：** 为了支持这个中间件，你不得不修改核心 `Processor` 接口（例如为其增加 DB 相关方法）。

---

## 📚 参考资料（Resources）

- [Go Proverbs by Rob Pike](https://go-proverbs.github.io/)
- [The Go Blog: Lexical Scanning in Go](https://blog.golang.org/lexical-scanning)
- [标准库示例：`net/http.Handler`](https://pkg.go.dev/net/http#Handler)
- [Small Interfaces in the Standard Library](https://medium.com/@cep21/small-interfaces-in-go-1e912a7a7883)



